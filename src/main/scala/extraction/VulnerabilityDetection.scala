package extraction

import extraction.Main._logger
import tools.Constants._
import tools.HexEditor.bytesToHex

import java.nio.file.{Path, Paths}
import java.security.MessageDigest
import java.text.SimpleDateFormat
import java.util.zip.{ZipEntry, ZipFile}
import scala.jdk.CollectionConverters.EnumerationHasAsScala

class VulnerabilityDetection {

  var _zipFile: Option[ZipFile] = None

  // keep track of found frameworks
  var _cordovaFound = false
  var _flutterFound = false
  var _reactNativeFound = false
  var _qtFound = false
  var _unityFound = false
  var _xamarinFound = false

  /**
   * Get the Android API and used framework versions, then write a JSON file as output,
   *
   * @param apkFilePath the given APK file path
   */
  def androidAppVulnerabilityDetection(apkFilePath: Path): Unit = {
    _logger.info("Starting application vulnerability detection")

    // make sure APK file name is given correctly
    if (!apkFilePath.getFileName.toString.endsWith(".apk")) {
      _logger.error(s"APK file does not have .apk file ending: $apkFilePath")
      _logger.warn("Make sure that filename does not have blank spaces")
      return
    }

    try {
      _zipFile = Some(new ZipFile(apkFilePath.toFile))
    } catch {
      case e: Throwable => _logger.error(s"File ${e.getMessage} is not found")
        return
    }
    _logger.info("Got the .apk filename " + apkFilePath)

    // extract the Android version information
    val android = new AndroidAPI()
    android.extractAndroidAPIVersion(apkFilePath.toString)

    val frameworks = new ExtractFrameworkVersions()
    var classDexLastModDate: String = null

    // iterate through the zip file and note which framework is used
    _logger.info("Looking for any sign of frameworks...")
    for (entry <- _zipFile.get.entries.asScala) {
      val classDexEntry = checkForFrameworks(entry)
      try {
        if (classDexEntry != null) {
          val sdf = new SimpleDateFormat("dd.MM.yyyy")
          classDexLastModDate = sdf.format(classDexEntry.getLastModifiedTime.toMillis)
        }
      } catch {
        case _: Throwable => _logger.warn("APK last modified date is not found")
      }
    }

    if (_flutterFound || _reactNativeFound || _qtFound || _xamarinFound || _unityFound || _cordovaFound) {
      // iterate through the zip file again and extract the found framework's version
      _logger.info("Starting frameworks version extraction")
      for (entry <- _zipFile.get.entries.asScala) {
        callVersionExtractionFunctions(entry, frameworks)
      }

      // set version from last modified date, if not found
      callVersionExtractionByDate(classDexLastModDate, frameworks)
      _logger.info("Finished frameworks version extraction")
    } else {
      _logger.info("No frameworks found")
    }

    // write the JSON value to JSON file
    (new JsonWriter).writeJsonFile(apkFilePath, this, android, frameworks)
    _logger.info("Finished application vulnerability detection")
  }

  /**
   * Hash the file at the given entry
   *
   * @param entry the current ZipEntry
   * @return the hash of the file at the entry
   */
  def hashFile(entry: ZipEntry): String = {
    var hash = ""
    try {
      val is = _zipFile.get.getInputStream(entry)
      hash = bytesToHex(MessageDigest.getInstance("SHA256").digest(is.readAllBytes())).mkString("")
    } catch {
      case e: Throwable => _logger.error(s"hashFile() throws an error with message: ${e.getMessage}")
    }
    hash
  }

  /**
   * Set true if a specific framework is found and return the entry if it contains the classes.dex.
   *
   * @param entry the current ZipEntry
   * @return the entry back if it contains classes.dex, null otherwise
   */
  def checkForFrameworks(entry: ZipEntry): ZipEntry = {
    try {
      if (entry.getName.toLowerCase.contains(flutterName.toLowerCase)) {
        if (!_flutterFound)
          _logger.info(s"$flutterName implementation found")
        _flutterFound = true
      }
      if (entry.getName.toLowerCase.contains(reactNativeShortName.toLowerCase)) {
        if (!_reactNativeFound)
          _logger.info(s"$reactNativeName implementation found")
        _reactNativeFound = true
      }
      if (entry.getName.toLowerCase.contains(qtName.toLowerCase)) {
        if (!_qtFound)
          _logger.info(s"$qtName implementation found")
        _qtFound = true
      }
      if (entry.getName.toLowerCase.contains(xamarinName.toLowerCase)) {
        if (!_xamarinFound)
          _logger.info(s"$xamarinName implementation found")
        _xamarinFound = true
      }
      if (entry.getName.toLowerCase.contains(cordovaName.toLowerCase)) {
        if (!_cordovaFound)
          _logger.info(s"$cordovaName implementation found")
        _cordovaFound = true
      }
      if (entry.getName.toLowerCase.contains(unityName.toLowerCase)) {
        if (!_unityFound)
          _logger.info(s"$unityName implementation found")
        _unityFound = true
      }
      if (entry.getName.contains(classDexFile)) {
        return entry
      }
    } catch {
      case e: Throwable => _logger.error(s"checkForFrameworks() throws an error with message: ${e.getMessage}")
    }
    null
  }

  /**
   * Call the corresponding function to extract framework's version.
   *
   * @param entry      the current ZipEntry
   * @param frameworks the ExtractFrameworkVersions object
   */
  def callVersionExtractionFunctions(entry: ZipEntry, frameworks: ExtractFrameworkVersions): Unit = {
    val hash = hashFile(entry)
    try {
      val entryName = Paths.get(entry.getName)
      var libType = ""
      if (entryName != null && entryName.getParent != null)
        libType = entryName.getParent.getFileName.toString

      if (entry.getName.contains(flutterFile)) {
        frameworks.compareHashes(flutterName, hash, libType)
      }
      if (entry.getName.matches(""".*""" + reactNativeFile)) {
        val fileName = entryName.getFileName.toString
        frameworks.compareReactNativeHashes(hash, fileName, libType)
      }
      if (entry.getName.matches(""".*""" + qtFile)) {
        frameworks.compareHashes(qtName, hash, libType)
      }
      if (entry.getName.contains(xamarinSoFile) || entry.getName.contains(xamarinDllFile)) {
        frameworks.compareHashes(xamarinName, hash, libType)
      }
      if (entry.getName.contains(cordovaFile)) {
        frameworks.extractCordovaVersion(_zipFile.get.getInputStream(entry))
      }
      if (entry.getName.contains(unitySoFile)) {
        frameworks.compareHashes(qtName, hash, libType)
      }
      if (entry.getName.matches(""".*""" + unityNumberedFile)) {
        frameworks.extractUnityVersion(_zipFile.get.getInputStream(entry))
      }
    } catch {
      case e: Throwable => _logger.error(s"callVersionExtractionFunctions() throws an error with message: ${e.getMessage}")
    }
  }

  /**
   * Make sure versions are found, otherwise the version will be determined through the app last modified date.
   *
   * @param lastModDate the date of the APK last modified
   * @param frameworks  the ExtractFrameworkVersions object
   */
  def callVersionExtractionByDate(lastModDate: String, frameworks: ExtractFrameworkVersions): Unit = {
    try {
      if (_flutterFound && !frameworks._frameworkVersions.contains(flutterName)) {
        frameworks.byDate(flutterName, lastModDate)
      }
      if (_reactNativeFound && !frameworks._frameworkVersions.contains(reactNativeName)) {
        frameworks.byDate(reactNativeName, lastModDate)
      }
      if (_qtFound && !frameworks._frameworkVersions.contains(qtName)) {
        frameworks.byDate(qtName, lastModDate)
      }
      if (_xamarinFound && !frameworks._frameworkVersions.contains(xamarinName)) {
        frameworks.byDate(xamarinName, lastModDate)
      }
      if (_cordovaFound && !frameworks._frameworkVersions.contains(cordovaName)) {
        frameworks.byDate(cordovaName, lastModDate)
      }
      if (_unityFound && !frameworks._frameworkVersions.contains(unityName)) {
        frameworks.byDate(unityName, lastModDate)
      }
    } catch {
      case e: Throwable => _logger.error(s"callVersionExtractionByDate() throws an error with message: ${e.getMessage}")
    }
  }
}
